# **算法分析与设计**

##       第一次实验报告

### （1）实验内容：随机生成一个包括n个整数得数组（元素取值范围为1~1000），利用插入排序、归并排序、快速排序、堆排序、基数排序、桶排序等算法对数组进行非降序排序，记录不同算法得运行时间。

​          实验记录：

​         1.生成随机数组：

随机数组生成函数代码如下：

```
int Create_Rand_Num(int temp[])
{
    int i;
    for(i=0;i<SIZE;i++)
    {
        temp[i]=rand()%RAND_MAX;
    }
}
```

 为了保证各算法比较时排序的初始数组一致，对每次排序都使用相同数组。在生成初始数组temp后，每次排序都将temp数组复制到a进行排序：

```
    int temp[SIZE];
    int a[SIZE];
    Create_Rand_Num(temp);
    memcpy(a,temp,sizeof temp) ;//temp[]是初始数组，a[]是用于排序的数组 
```

 

​          2.验证排序算法准确性：

为了保证排序算法正确性，在实验中先用小数组进行排序，打印出排序结果。

![image-20221023190846731](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023190846731.png)



![image-20221023191111645](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023191111645.png)

可见，排序功能可以正常实现。



### （2）实验内容：改变数组规模 ***n\*** = 5万、10万、20万、30万、50万，记录不同规模下各个算法的排序时间。

| 数组规模\算法      | 插入排序 | 归并排序 | 快速排序 | 堆排序 | 基数排序 | 桶排序 |
| ------------------ | -------- | -------- | -------- | ------ | -------- | ------ |
| 50000 （3位数）    | 0.937    | 0.000    | 0.000    | 0.000  | 0.015    | 0.000  |
| 100000   （4位数） | 3.726    | 0.015    | 0.000    | 0.015  | 0.016    | 0.000  |
| 200000   （4位数） | 14.636   | 0.010    | 0.032    | 0.023  | 0.018    | 0.000  |
| 300000   （4位数） | 33.522   | 0.038    | 0.027    | 0.041  | 0.023    | 0.001  |
| 300000   （5位数） | 33.874   | 0.041    | 0.025    | 0.038  | 0.028    | 0.001  |
| 500000   （5位数） | 93.780   | 0.064    | 0.051    | 0.067  | 0.031    | 0.018  |



### （3）实验内容：对固定规模 （***n\*** = 10万）的数组进行随机扰乱，对扰乱后的数组进行排序并记录各个算法的排序时间。本实验要求重复5次，观察输入数据分布和运行时间的关系。

初始设置数组大小为10w，取值范围为1~1w。采用五种分布的数组对各排序算法进行测试。结果如下表所示

| 数组样式\算法 | 插入排序 | 归并排序 | 快速排序 | 堆排序 | 基数排序 | 桶排序 |
| ------------- | -------- | -------- | -------- | ------ | -------- | ------ |
| 随机扰乱      | 3.672    | 0.000    | 0.016    | 0.015  | 0.000    | 0.000  |
| 降序          | 7.406    | 0.000    | 2.838    | 0.007  | 0.008    | 0.001  |
| 大量重复      | 3.688    | 0.000    | 0.015    | 0.016  | 0.000    | 0.000  |
| 部分升序      | 3.590    | 0.000    | 0.016    | 0.015  | 0.000    | 0.016  |
| 数值范围扩大  | 3.743    | 0.012    | 0.007    | 0.011  | 0.011    | 0.001  |



###### 随机扰乱：在对随机数组不进行任何操作的情况下，对各排序算法进行测试。

###### 由于发现多次测试的数据不尽相同，因此测试五次结果，汇总，结果如下图：

| 实验次数 | 插入排序 | 归并排序 | 快速排序 | 堆排序 | 基数排序 | 桶排序 |
| -------- | -------- | -------- | -------- | ------ | -------- | ------ |
| 1        | 3.826    | 0.012    | 0.008    | 0.011  | 0.010    | 0.001  |
| 2        | 3.772    | 0.000    | 0.021    | 0.007  | 0.008    | 0.001  |
| 3        | 3.703    | 0.015    | 0.016    | 0.001  | 0.016    | 0.000  |
| 4        | 3.781    | 0.013    | 0.008    | 0.011  | 0.009    | 0.001  |
| 5        | 3.753    | 0.014    | 0.008    | 0.011  | 0.001    | 0.000  |
| 平均     | 3.767    | 0.011    | 0.012    | 0.008  | 0.009    | 0.001  |

由数据分析可见，插入排序算法的时间复杂度显著大于其他排序的时间，为O(n*n)，而归并排序，快速排序，堆排序，基数排序的平均时间较为接近，前三者的时间复杂度均为O(nlog(n))。在实验中基数排序运行时间较长，接近与O(nlog(n))，实际上应该为O(n+k),原因可能是实验代码中有冗余，以及实验测试数据分布不同导致。而桶排序的运行时间较快，是因为在该算法中，一共设置了与数值中数值最大值相当的桶，内存花费较大，为O(n)，开辟了大量空间（链表）来存储桶。

即使数组大小为200w，桶排序性能也十分突出，如图所示：

![img](file:///C:\Users\LiangZhaoYi\AppData\Roaming\Tencent\Users\710981348\QQ\WinTemp\RichOle\]0DD4U2@]}T[U56_$H8WL2W.png)



###### 对随机数组进行降序处理后，再进行排序，结果如图所示：

```
//    BucketSort0(temp, SIZE); //利用桶排序进行降序操作  
```

![image-20221023224109002](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023224109002.png)

在该情况下，插入排序与快速排序都达到了最大时间复杂度，花费的时间较大，达到O(n*n)。部分误差是由于实验代码冗余导致。



###### 对随机数组每一千个进行升序排序，然后组合成一个大小为十万的数组，再进行排序，数组处理后结果如图所示：

![image-20221023224238992](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023224238992.png)

排序算法运行时间：

![image-20221023224253146](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023224253146.png)

多次测试后发现，快速排序的性能得到显著的提升，在预排序后，快速排序的交换次数大大减小，因此其性能的有所提升。

图中桶排序较慢，可能是因为重复的数字增加，导致桶的深度增加，影响排序时间。



###### 将数值范围设置为1000，进行排序，结果如图所示：

![image-20221023224521981](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023224521981.png)

###### 将数组范围设置为32767，结果如图所示：

![image-20221023224926161](C:\Users\LiangZhaoYi\AppData\Roaming\Typora\typora-user-images\image-20221023224926161.png)

可见，在数组中数值重复率减少的情况下，排序算法的时间变得更加稳定，减少了多次实验时排序时间的波动。但其对排序时间长短的影响并不显著。

由于生成随机的范围只能为0~32767，因此无法用100w的数值范围来测试。

### 实验总结：

​    本次实验对各个排序算法进行测试，在实验中，遇到了许多意外情况。例如在堆排序中，堆的大小溢出导致排序无输出；桶排序速度太快，导致一度以为算法出现bug。最后都在实验中得到解决，如堆排序中使数组向后移一位来适应堆的大小。此外在实验中使用了Dev c++编译器，对调试以及debug十分不友好，在后面改用了VS code后情况得到改善。

​	

